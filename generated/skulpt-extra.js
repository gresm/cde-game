// This file was automatically generated. Don't change it.
export default JSON.parse(String.raw`{"./document2.js":"function numberToPy(val){return Number.isInteger(val)?Math.abs(val)<Number.MAX_SAFE_INTEGER?new Sk.builtin.int_(val):new Sk.builtin.int_(JSBI.BigInt(val)):new Sk.builtin.float_(val)}function toPyDict(obj,hooks,mapped){const ret=new Sk.builtin.dict;return Object.entries(obj).forEach(([key,val])=>{var s=new Sk.builtin.str(key);mapped.set(key,s),ret.mp$ass_subscript(s,toPy(val,hooks,mapped))}),ret}const _proxied=new WeakMap;function proxy(obj,flags){if(null==obj)return Sk.builtin.none.none$;var type=typeof obj;if(\"object\"!=type&&\"function\"!=type)return toPy(obj);flags=flags||{};type=_proxied.get(obj);if(type){if(flags.bound===type.$bound)return type;flags.name||(flags.name=type.$name)}type=new JsProxy(obj,flags);return _proxied.set(obj,type),type}const JsProxy=Sk.abstr.buildNativeClass(\"Proxy\",{constructor:function(obj,flags){if(void 0===obj)throw new Sk.builtin.TypeError(\"Proxy cannot be called from python\");this.js$wrapped=obj,this.$module=null,this.$methods=Object.create(null),this.in$repr=!1,flags=flags||{},Object.defineProperties(this,this.memoized$slots),\"function\"==typeof obj?(this.is$callable=!0,this.$bound=flags.bound,this.$name=flags.name||obj.name||\"(native JS)\",this.$name.length<=2&&(this.$name=this.$name+\" (native JS)\")):(this.is$callable=!1,delete this.is$type,this.is$type=!1,this.$name=flags.name)},slots:{tp$doc:\"proxy for a javascript object\",tp$hash(){return Sk.builtin.object.prototype.tp$hash.call(this.js$wrapped)},tp$getattr(pyName){return this.$lookup(pyName)||Sk.generic.getAttr.call(this,pyName)},tp$setattr(pyName,value){pyName=pyName.toString();void 0===value?delete this.js$wrapped[pyName]:this.js$wrapped[pyName]=toJs(value,jsHooks)},$r(){if(this.is$callable){if(this.is$type||!this.$bound)return new Sk.builtin.str(\"<\"+this.tp$name+\" '\"+this.$name+\"'>\");var boundRepr=Sk.misceval.objectRepr(proxy(this.$bound));return new Sk.builtin.str(\"<bound \"+this.tp$name+\" '\"+this.$name+\"' of \"+boundRepr+\">\")}if(this.js$proto===OBJECT_PROTO){if(this.in$repr)return new Sk.builtin.str(\"{...}\");this.in$repr=!0;const entries=Object.entries(this.js$wrapped).map(([key,val])=>(val=toPy(val,boundHook(this.js$wrapped,key)),\"'\"+key+\"': \"+Sk.misceval.objectRepr(val)));boundRepr=new Sk.builtin.str(\"proxyobject({\"+entries.join(\", \")+\"})\");return this.in$repr=!1,boundRepr}boundRepr=\"proxyobject\"===this.tp$name?\"object\":\"proxyobject\";return new Sk.builtin.str(\"<\"+this.tp$name+\" \"+boundRepr+\">\")},tp$as_sequence_or_mapping:!0,mp$subscript(pyItem){var ret=this.$lookup(pyItem);if(void 0===ret)throw new Sk.builtin.LookupError(pyItem);return ret},mp$ass_subscript(pyItem,value){return this.tp$setattr(pyItem,value)},sq$contains(item){return toJs(item)in this.js$wrapped},ob$eq(other){return this.js$wrapped===other.js$wrapped},ob$ne(other){return this.js$wrapped!==other.js$wrapped},tp$as_number:!0,nb$bool(){return this.js$proto===OBJECT_PROTO?0<Object.keys(this.js$wrapped).length:!this.sq$length||0<this.sq$length()}},methods:{__dir__:{$meth(){const proxy_dir=Sk.misceval.callsimArray(Sk.builtin.type.prototype.__dir__,[JsProxy]).valueOf();return new Sk.builtin.list(proxy_dir.concat(Array.from(this.$dir,x=>new Sk.builtin.str(x))))},$flags:{NoArgs:!0}},__new__:{$meth(js_proxy,...args){if(!(js_proxy instanceof JsProxy))throw new Sk.builtin.TypeError(\"expected a proxy object as the first argument not \"+Sk.abstr.typeName(js_proxy));try{return js_proxy.$new(args)}catch(e){if(e instanceof TypeError&&e.message.includes(\"not a constructor\"))throw new Sk.builtin.TypeError(Sk.misceval.objectRepr(js_proxy)+\" is not a constructor\");throw e}},$flags:{MinArgs:1}},__call__:{$meth(args,kwargs){if(\"function\"!=typeof this.js$wrapped)throw new Sk.builtin.TypeError(\"'\"+this.tp$name+\"' object is not callable\");return this.$call(args,kwargs)},$flags:{FastCall:!0}},keys:{$meth(){return new Sk.builtin.list(Object.keys(this.js$wrapped).map(x=>new Sk.builtin.str(x)))},$flags:{NoArgs:!0}},get:{$meth(pyName,_default){return this.$lookup(pyName)||_default||Sk.builtin.none.none$},$flags:{MinArgs:1,MaxArgs:2}}},getsets:{__class__:{$get(){return toPy(this.js$wrapped.constructor,pyHooks)},$set(){throw new Sk.builtin.TypeError(\"not writable\")}},__name__:{$get(){return new Sk.builtin.str(this.$name)}},__module__:{$get(){return this.$module||Sk.builtin.none.none$},$set(v){this.$module=v}}},proto:{valueOf(){return this.js$wrapped},$new(args,kwargs){return Sk.abstr.checkNoKwargs(\"__new__\",kwargs),toPy(new this.js$wrapped(...args.map(x=>toJs(x,jsHooks))),{dictHook:obj=>proxy(obj),proxyHook:obj=>proxy(obj,{name:this.$name})})},$call(args,kwargs){return Sk.abstr.checkNoKwargs(\"__call__\",kwargs),Sk.misceval.chain(this.js$wrapped.apply(this.$bound,args.map(x=>toJs(x,jsHooks))),res=>res instanceof Promise?Sk.misceval.promiseToSuspension(res):res,res=>toPy(res,pyHooks))},$lookup(pyName){var pyName=pyName.toString(),attr=this.js$wrapped[pyName];return void 0!==attr?toPy(attr,boundHook(this.js$wrapped,pyName)):pyName in this.js$wrapped?Sk.builtin.none.none$:void 0},memoized$slots:{js$proto:{configurable:!0,get(){return delete this.js$proto,this.js$proto=Object.getPrototypeOf(this.js$wrapped)}},$dir:{configurable:!0,get(){const dir=[];let obj=this.js$wrapped;for(;null!=obj&&obj!==OBJECT_PROTO&&obj!==FUNC_PROTO;)dir.push(...Object.getOwnPropertyNames(obj)),obj=Object.getPrototypeOf(obj);return new Set(dir)}},tp$iter:{configurable:!0,get(){return delete this.tp$iter,void 0!==this.js$wrapped[Symbol.iterator]?this.tp$iter=()=>proxy(this.js$wrapped[Symbol.iterator]()):this.tp$iter=()=>{throw new Sk.builtin.TypeError(Sk.misceval.objectRepr(this)+\" is not iterable\")}}},tp$iternext:{configurable:!0,get(){if(delete this.tp$iternext,void 0!==this.js$wrapped.next)return this.tp$iternext=()=>{var nxt=this.js$wrapped.next().value;return nxt&&toPy(nxt,pyHooks)}}},sq$length:{configurable:!0,get(){if(delete this.sq$length,!this.is$callable&&void 0!==this.js$wrapped.length)return this.sq$length=()=>this.js$wrapped.length}},tp$call:{configurable:!0,get(){if(delete this.tp$call,this.is$callable)return this.tp$call=this.is$type?this.$new:this.$call}},tp$name:{configurable:!0,get(){if(delete this.tp$name,this.is$callable)return this.tp$name=this.is$type?\"proxyclass\":this.$bound?\"proxymethod\":\"proxyfunction\";{var obj=this.js$wrapped;let tp$name=obj[Symbol.toStringTag]||this.$name||obj.constructor&&obj.constructor.name||\"proxyobject\";return\"Object\"===tp$name?(tp$name=this[Symbol.toStringTag],tp$name=\"proxyobject\"):tp$name.length<=2&&(tp$name=proxy(obj.constructor).$name),this.tp$name=tp$name}}},is$type:{configurable:!0,get(){delete this.is$type;var jsFunc=this.js$wrapped,proto=jsFunc.prototype;if(void 0===proto)return this.is$type=jsFunc===window.Proxy;jsFunc=checkBodyIsMaybeConstructor(jsFunc);return!0===jsFunc?this.is$type=!0:!1===jsFunc?this.is$type=!1:1<Object.getOwnPropertyNames(proto).length?this.is$type=!0:this.is$type=Object.getPrototypeOf(proto)!==OBJECT_PROTO}}}},flags:{sk$acceptable_as_base_class:!1}});function toPySet(obj,hooks,mapped){return new Sk.builtin.set(Array.from(obj,x=>toPy(x,hooks,mapped)))}function toPy(obj,hooks,mapped){if(null==obj)return Sk.builtin.none.none$;if(obj.sk$object)return obj;if(obj.$isPyWrapped&&obj.unwrap)return obj.unwrap();if((mapped=void 0===mapped?new WeakMap:mapped).has(obj))return mapped.get(obj);wrap=(val,ob)=>(mapped.set(void 0===ob?obj:ob,val),val);var type=typeof obj;if(hooks=hooks||{},\"string\"==type)return wrap(new Sk.builtin.str(obj));if(\"number\"==type)return wrap(numberToPy(obj));if(\"boolean\"==type)return wrap(new Sk.builtin.bool(obj));if(\"function\"==type)return wrap(hooks.funcHook?hooks.funcHook(obj):proxy(obj));if(JSBI.__isBigInt(obj))return wrap(new Sk.builtin.int_(JSBI.numberIfSafe(obj)));if(Array.isArray(obj))return wrap(new Sk.builtin.list(obj.map(x=>toPy(x,hooks,mapped))));if(\"object\"==type){var constructor=obj.constructor;if(constructor===Object&&Object.getPrototypeOf(obj)===OBJECT_PROTO||void 0===constructor)return wrap(hooks.dictHook?hooks.dictHook(obj):toPyDict(obj,hooks));if(constructor===Uint8Array)return wrap(new Sk.builtin.bytes(obj));if(constructor===Set)return wrap(toPySet(obj,hooks));if(constructor!==Map)return constructor===Sk.misceval.Suspension?obj:wrap(hooks.proxyHook?hooks.proxyHook(obj):proxy(obj));{const ret=new Sk.builtin.dict;return obj.forEach((val,key)=>{ret.mp$ass_subscript(toPy(key,hooks,mapped),toPy(val,hooks,mapped))}),wrap(ret)}}if(hooks.unhandledHook)return wrap(hooks.unhandledHook(obj));Sk.asserts.fail(\"unhandled remap case of type \"+type)}function $builtinmodule(){const{builtin:{str:pyStr},ffi:{remapToPy:toPy},abstr:{gattr}}=Sk;var documentMod={__name__:new pyStr(\"document\")};const documentProxy=toPy(Sk.global.document);return Sk.abstr.setUpModuleMethods(\"document\",documentMod,{__getattr__:{$meth(pyName){return gattr(documentProxy,pyName,!0)},$flags:{OneArg:!0}},__dir__:{$meth(){return pyCall(documentProxy.tp$getattr(pyStr.$dir))},$flags:{NoArgs:!0}}}),documentMod}","./game_interface.js":"var $builtinmodule=function(name){var mod={};return mod.__name__=new Sk.builtin.str(\"game_interface\"),mod.get_story=new Sk.builtin.func(function(){return Sk.builtin.pyCheckArgsLen(\"get_story\",arguments.length,0,0),Sk.ffi.remapToPy(Sk.gameInterface.story)}),mod.gameDiv=new Sk.builtin.func(function(){if(void 0!==Sk.divid)return new Sk.builtin.str(Sk.divid);throw new Sk.builtin.AttributeError(\"There is no value set for divid\")}),mod};","./hello.py":"def hello(person):\n    return f\"Hello {person}!\"","./hstt_runner.py":"\"\"\"\nUtility script to run HSTT formatted json files.\n\"\"\"\nimport sys\n\nif sys.version == \"3.7(ish) [Skulpt]\":\n    class _getitem:\n        def __getitem__(self, name):\n            return name\n    \n    Optional = _getitem()\n    Union = _getitem()\nelse:\n    from typing import Optional, Union\n\n\nclass HSTTParserException(Exception):\n    pass\n\n\nclass TextLine:\n    \"\"\"\n    Class for text lines.\n    \"\"\"\n    def __init__(self, text: str, text_type: str):\n        self.text = text\n        self.type = text_type\n\n    def __repr__(self):\n        return f\"{self.type}: {self.text}\"\n\n    @classmethod\n    def parse(cls, data: dict[str, str]):\n        \"\"\"\n        Parses text line from dictionary.\n        \"\"\"\n        return cls(data[\"text\"], data[\"type\"])\n\n\nclass NodeText:\n    \"\"\"\n    Class to represent text in a node.\n    \"\"\"\n    def __init__(self, text: list[TextLine]):\n        self.text = text\n\n    def __repr__(self):\n        return f'[{\", \".join([str(line) for line in self.text])}]'\n\n    @classmethod\n    def parse(cls, data: list[dict[str, str]]):\n        \"\"\"\n        Parses text from list of dictionaries.\n        \"\"\"\n        return cls([TextLine.parse(line) for line in data])\n\n\nclass OptionElement:\n    \"\"\"\n    Class to represent option element.\n    \"\"\"\n    def __init__(self, text: str, goto: str):\n        self.text = text\n        self.goto = goto\n\n    def __repr__(self):\n        return f'{self.text} -> {self.goto}'\n\n    @classmethod\n    def parse(cls, data: tuple[str, str]):\n        \"\"\"\n        Parses option element from tuple.\n        \"\"\"\n        return cls(data[0], data[1])\n\n\nclass NodeOptions:\n    \"\"\"\n    Class to represent options in a node.\n    \"\"\"\n    def __init__(self, options: list[OptionElement]):\n        self.options = options\n\n    def __bool__(self):\n        return len(self.options) > 0\n\n    def __repr__(self):\n        return f'[{\", \".join([str(option) for option in self.options])}]'\n\n    @classmethod\n    def parse(cls, data: dict[str, str]):\n        \"\"\"\n        Parses options from list of dictionaries.\n        \"\"\"\n        return cls([OptionElement.parse(option) for option in data.items()])\n\n\nclass StoryNode:\n    def __init__(self, name: str, text: NodeText, options: NodeOptions, goto: Optional[str] = None):\n        self.name = name\n        self.text = text\n        self.goto = goto\n        self.options = options\n\n    def __repr__(self):\n        return f'{self.name}:\\n{self.text}\\n{self.options}'\n\n    @classmethod\n    def parse(cls, data: Union[dict[str, list[dict[str, str]], dict[str, str]], str]):\n        \"\"\"\n        Parses story node from dictionary.\n        \"\"\"\n        return cls(\n            data[\"name\"],\n            NodeText.parse(data[\"text\"]),\n            NodeOptions.parse(data.get(\"options\", {})),\n            data.get(\"goto\")\n        )\n\n\nclass Story:\n    def __init__(self, nodes: dict[str, StoryNode]):\n        self.nodes = nodes\n\n    def __repr__(self):\n        return f'{self.nodes}'\n\n    def __iter__(self):\n        return HSTTRunner(self)\n\n    @classmethod\n    def parse(cls, data: Union[dict[str, dict[str, list[dict[str, str]], dict[str, str]], str]]):\n        \"\"\"\n        Parses story from dictionary.\n        \"\"\"\n        ret = cls({\n            name: StoryNode.parse(data[name]) for name in data\n        })\n        ret.validate()\n        return ret\n\n    def validate(self):\n        \"\"\"\n        Validates story.\n        \"\"\"\n        for node_name in self.nodes:\n            node = self.nodes[node_name]\n            if node.goto and node_name not in self.nodes:\n                raise HSTTParserException(f\"Node {node_name} has goto {node.goto} but there is not such location.\")\n\n            if node.options:\n                for option in node.options.options:\n                    if option not in self.nodes:\n                        raise HSTTParserException(f\"Node {node_name} has option {option.text} -> {option.goto} but \"\n                                                  f\"there is not such location.\")\n\n            if node.goto and node.options:\n                raise HSTTParserException(f\"Collision in: {node_name}. The node has both goto and options. \"\n                                          f\"This behaviour is not supported.\")\n\n        if \"\" not in self.nodes:\n            raise HSTTParserException(\"There is no start node.\")\n\n\nclass HSTTRunnerCurrentNode:\n    def __init__(self, runner: \"HSTTRunner\", text: NodeText, options: NodeOptions):\n        self.runner = runner\n        self.text = text\n        self.options = options\n        self.selected = None\n\n    def select(self, option: str):\n        \"\"\"\n        Selects option.\n        \"\"\"\n        if option not in self.options.options:\n            raise HSTTParserException(f\"Option {option} is not available.\")\n        self.selected = option\n\n\nclass HSTTRunner:\n    \"\"\"\n    Runner class, an iterator utility for HSTT.\n    \"\"\"\n    def __init__(self, story: Story):\n        self.story = story\n        self.current_node = self.story.nodes[\"\"]\n        self.selected_option: Union[str, None] = None\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.current_node.goto:\n            self.current_node = self.story.nodes[self.current_node.goto]\n","./test.js":"console.log(\"This is a test\");"}`)