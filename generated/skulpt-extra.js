// This file was automatically generated. Don't change it.
const val = {"./game_interface.js":"var $builtinmodule=function(name){var mod={};return mod.__name__=new Sk.builtin.str(\"game_interface\"),mod.get_story=new Sk.builtin.func(function(){return Sk.builtin.pyCheckArgsLen(\"get_story\",arguments.length,0,0),Sk.ffi.remapToPy(Sk.gameInterface.story)}),mod.game_div=new Sk.builtin.func(function(){if(void 0!==Sk.divid)return new Sk.builtin.str(Sk.divid);throw new Sk.builtin.AttributeError(\"There is no value set for divid\")}),mod};","./hello.py":"def hello(person):\n    return f\"Hello {person}!\"\n","./hstt_runner.py":"\"\"\"\nUtility script to run HSTT formatted json files.\n\"\"\"\nfrom typing import Literal, Optional, TypeAlias\n\nfrom typing_extensions import NotRequired, TypedDict\n\n\nclass RawTextLine(TypedDict):\n    text: str\n    type: Literal[\"text\", \"alert\"]\n\n\nRawNodeText: TypeAlias = \"list[RawTextLine]\"\nRawNodeOptions: TypeAlias = \"list[list[str]]\"\n\n\nclass RawStoryNode(TypedDict):\n    text: RawNodeText\n    options: NotRequired[RawNodeOptions]\n    goto: NotRequired[str]\n\n\nclass RawStory(TypedDict):\n    title: str\n    nodes: dict[str, RawStoryNode]\n\n\nclass HSTTParserException(Exception):\n    pass\n\n\nclass TextLine:\n    \"\"\"\n    Class for text lines.\n    \"\"\"\n\n    def __init__(self, text: str, text_type: str):\n        self.text = text\n        self.type = text_type\n\n    def __repr__(self):\n        return f\"{self.type}: {self.text}\"\n\n    @classmethod\n    def parse(cls, data: RawTextLine):\n        \"\"\"\n        Parses text line from dictionary.\n        \"\"\"\n        return cls(data[\"text\"], data[\"type\"])\n\n\nclass NodeText:\n    \"\"\"\n    Class to represent text in a node.\n    \"\"\"\n\n    def __init__(self, text: list[TextLine]):\n        self.text = text\n\n    def __repr__(self):\n        return f'[{\", \".join([str(line) for line in self.text])}]'\n\n    @classmethod\n    def parse(cls, data: list[RawTextLine]):\n        \"\"\"\n        Parses text from list of dictionaries.\n        \"\"\"\n        return cls([TextLine.parse(line) for line in data])\n\n\nclass OptionElement:\n    \"\"\"\n    Class to represent option element.\n    \"\"\"\n\n    def __init__(self, goto: str, text: str):\n        self.text = text\n        self.goto = goto\n\n    def __repr__(self):\n        return f\"{self.text} -> {self.goto}\"\n\n    @classmethod\n    def parse(cls, data: tuple[str, str]):\n        \"\"\"\n        Parses option element from tuple.\n        \"\"\"\n        return cls(data[0], data[1])\n\n\nclass NodeOptions:\n    \"\"\"\n    Class to represent options in a node.\n    \"\"\"\n\n    def __init__(self, options: list[OptionElement]):\n        self.options = options\n\n    def __bool__(self):\n        return len(self.options) > 0\n\n    def __repr__(self):\n        return f'[{\", \".join([str(option) for option in self.options])}]'\n\n    @classmethod\n    def parse(cls, data: RawNodeOptions):\n        \"\"\"\n        Parses options from list of dictionaries.\n        \"\"\"\n        return cls([OptionElement.parse((option[0], option[1])) for option in data])\n\n\nclass StoryNode:\n    def __init__(\n        self,\n        name: str,\n        text: NodeText,\n        options: NodeOptions,\n        goto: Optional[str] = None,\n    ):\n        self.name = name\n        self.text = text\n        self.goto = goto\n        self.options = options\n\n    def __repr__(self):\n        return f\"{self.name}:\\n{self.text}\\n{self.options}\"\n\n    @classmethod\n    def parse(cls, name: str, data: RawStoryNode):\n        \"\"\"\n        Parses story node from dictionary.\n        \"\"\"\n        return cls(\n            name,\n            NodeText.parse(data[\"text\"]),\n            NodeOptions.parse(data.get(\"options\", [])),\n            data.get(\"goto\", None),\n        )\n\n\nclass Story:\n    def __init__(self, title: str, nodes: dict[str, StoryNode]):\n        self.title = title\n        self.nodes = nodes\n        self.entry_point = nodes[\"\"]\n\n    def __repr__(self):\n        return f\"{self.nodes}\"\n\n    def __iter__(self):\n        return HSTTRunner(self)\n\n    @classmethod\n    def parse(\n        cls,\n        data: RawStory,\n    ):\n        \"\"\"\n        Parses story from dictionary.\n        \"\"\"\n        ret = cls(\n            data[\"title\"],\n            {\n                name: StoryNode.parse(name, value)\n                for name, value in data[\"nodes\"].items()\n            },\n        )\n        ret.validate()\n        return ret\n\n    def validate(self):\n        \"\"\"\n        Validates story.\n        \"\"\"\n        for node_name in self.nodes:\n            node = self.nodes[node_name]\n            if node.goto is not None and node.goto not in self.nodes:\n                raise HSTTParserException(\n                    f\"Node {node_name} has goto {node.goto} but there is not such location.\"\n                )\n\n            if node.options:\n                for option in node.options.options:\n                    if option.goto not in self.nodes:\n                        raise HSTTParserException(\n                            f\"Node {node_name} has option {option.text} -> {option.goto} but \"\n                            f\"there is not such location.\"\n                        )\n\n            if node.goto and node.options:\n                raise HSTTParserException(\n                    f\"Collision in: {node_name}. The node has both goto and options. \"\n                    f\"This behaviour is not supported.\"\n                )\n\n        if \"\" not in self.nodes:\n            raise HSTTParserException(\"There is no start node.\")\n\n\nclass Progress:\n    def __init__(self, requires_input: bool, to_show: str, is_alert: bool) -> None:\n        self.requires_input = requires_input\n        self.to_show = to_show\n        self.is_alert = is_alert\n\n\nclass HSTTRunner:\n    \"\"\"\n    Runner class, an iterator utility for HSTT.\n    \"\"\"\n\n    def __init__(self, story: Story):\n        self.story = story\n        self.location = self.story.entry_point\n        self.progress = Progress(\n            bool(self.location.options) and not len(self.location.text.text),\n            self.story.title,\n            False,\n        )\n\n    def step(self):\n        pass\n","./test.js":"console.log(\"This is a test\");","./typing.py":"class _getitem:\n    def __getitem__(self, name):\n        return name\n\n\nOptional = _getitem()\nUnion = _getitem()\nLiteral = _getitem()\nTypeAlias = _getitem()\n","./typing_extensions.py":"class _getitem:\n    def __getitem__(self, name):\n        return name\n\n\nNotRequired = _getitem()\n\n\nclass TypedDict(dict):\n    pass\n"};
export default val;